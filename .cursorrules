# Flutter Feature-First Architecture 開発ガイド

このプロジェクトは **Feature-First アーキテクチャ** に従って開発します。
`flutter_feature_first_prompt.md` を参考に、機能単位でコードを整理してください。

## 📋 基本方針

### Feature-First アーキテクチャの原則

1. **機能単位でコードを整理**: レイヤー（data/domain/presentation）ではなく、**機能（feature）ごと**にフォルダを作成
2. **各 feature は独立**: 他の feature に直接依存しない
3. **3層構造**: 各 feature は `data/`, `domain/`, `presentation/` の3層を持つ

## 🏗️ プロジェクト構造

```
lib/
├── main.dart
├── app.dart                          # MaterialApp の設定
│
├── core/                             # 共通機能・ユーティリティ
│   ├── di/                           # Dependency Injection
│   ├── theme/                        # テーマ・スタイル
│   ├── constants/                    # 定数
│   ├── utils/                        # ユーティリティ関数
│   ├── extensions/                   # Dart拡張
│   ├── router/                       # ルーティング
│   └── error/                        # エラーハンドリング
│
├── shared/                           # 複数featureで共有するコンポーネント
│   ├── widgets/                      # 共通ウィジェット
│   ├── models/                       # 共通モデル
│   ├── services/                     # 共通サービス
│   └── repositories/                 # 共通リポジトリ
│
└── features/                         # 機能単位のモジュール
    ├── authentication/               # 認証機能
    ├── home/                         # ホーム機能
    ├── profile/                      # プロフィール機能
    └── settings/                     # 設定機能
```

## 📝 実装時のルール

### 1. Feature の構造

各 feature は以下の3層構造を持ちます：

#### Data Layer（データ層）
- `models/`: JSON とやり取りするためのデータモデル
- `datasources/`: API 呼び出しやローカルストレージへのアクセス
- `repositories/`: domain layer のリポジトリインターフェースの実装

#### Domain Layer（ドメイン層）
- `entities/`: ビジネスモデル（UIやDBに依存しない純粋なDartクラス）
- `repositories/`: データ取得のインターフェース（抽象クラス）
- `usecases/`: 特定のビジネスロジックを実行（Single Responsibility）

#### Presentation Layer（プレゼンテーション層）
- `providers/`: 状態管理（Riverpod推奨）
- `screens/`: 画面（各 feature の画面）
- `widgets/`: その feature 専用のウィジェット

### 2. Core と Shared の使い分け

#### core/
- アプリ全体で使用される**基盤的な機能**
- 例: DI、ルーティング、テーマ、定数、エラーハンドリング
- **ビジネスロジックを含まない**

#### shared/
- 複数の feature で**再利用されるコンポーネント**
- 例: 共通ウィジェット、共通モデル、共通サービス
- **ビジネスロジックを含む場合がある**

### 3. 新しい Feature を追加する手順

1. **フォルダ構造を作成**
   ```
   lib/features/{feature_name}/
   ├── data/
   │   ├── models/
   │   ├── datasources/
   │   └── repositories/
   ├── domain/
   │   ├── entities/
   │   ├── repositories/
   │   └── usecases/
   └── presentation/
       ├── providers/
       ├── screens/
       └── widgets/
   ```

2. **Domain Layer から実装**
   - Entity を定義
   - Repository のインターフェースを定義
   - UseCase を実装

3. **Data Layer を実装**
   - Model を作成（JSON <-> Entity 変換）
   - DataSource を実装
   - Repository の実装を作成

4. **Presentation Layer を実装**
   - Provider/Notifier を作成
   - Screen を作成
   - Widget を作成

5. **DI に登録** (`core/di/injection.dart`)

## ✅ ベストプラクティス

### DO ✅

- ✅ 1つの feature は独立している（他の feature に依存しない）
- ✅ `shared/` に共通コンポーネントを配置
- ✅ UseCase は1つのことだけをする（Single Responsibility）
- ✅ Model と Entity を分離する
- ✅ DI を使用してテスタブルにする
- ✅ `Either<Failure, T>` でエラーハンドリング（fpdart または dartz）

### DON'T ❌

- ❌ feature 間で直接依存しない
- ❌ Presentation Layer で直接 API を叩かない
- ❌ Domain Layer に Flutter の Widget を使わない
- ❌ すべてを `shared/` に入れない（本当に共有されるものだけ）

## 🎯 コード実装時の注意事項

1. **新しい機能を追加する際は、必ず feature フォルダを作成する**
2. **既存の feature を修正する際は、その feature 内のファイルのみを編集する**
3. **共通機能が必要な場合は、`core/` または `shared/` に配置するか検討する**
4. **ファイルを作成する際は、適切なディレクトリ構造に従う**
5. **DI を使用する場合は、`core/di/injection.dart` に登録する**

## 📦 推奨パッケージ

- 状態管理: `flutter_riverpod`
- ルーティング: `go_router`
- エラーハンドリング: `dartz` または `fpdart`
- HTTP: `dio`
- ローカルストレージ: `shared_preferences` または `hive`
- JSON シリアライゼーション: `freezed`, `json_serializable`

## 📚 詳細な実装例

詳細な実装例やコードサンプルは `flutter_feature_first_prompt.md` を参照してください。

---

**重要**: このプロジェクトでコードを実装・修正する際は、必ずこの Feature-First アーキテクチャに従ってください。





# Flutter Test Code Development Standards

あなたはFlutterの経験豊富な開発者です。以下の基準に従ってテストコードを作成してください。

## 基本原則

1. **テストファースト**: 実装コードの前にテストコードを書く
2. **AAA パターン**: Arrange（準備）、Act（実行）、Assert（検証）を明確に分ける
3. **1テスト1検証**: 1つのテストで1つの事柄のみを検証する
4. **独立性**: テスト間で依存関係を持たせない
5. **再現性**: 何度実行しても同じ結果になる

## カバレッジ目標

- 全体カバレッジ: 80%以上
- ビジネスロジック: 90%以上
- UIウィジェット: 70%以上
- 重要な機能: 100%

## テストの種類と役割

### Unit Test（単体テスト）
**対象**: モデル、サービス、ユーティリティ、ビジネスロジック

**必須テストケース**:
- 正常系: 期待通りの入力で期待通りの出力
- 異常系: 不正な入力でエラーハンドリング
- 境界値: 最小値、最大値、境界値
- null/空値: null、空文字列、空リストの処理

**命名規則**:
```dart
test('メソッド名_条件_期待される結果', () {
  // 例: 'add_positiveNumbers_returnsSum'
});
```

### Widget Test（ウィジェットテスト）
**対象**: UIコンポーネント、画面

**必須テストケース**:
- レンダリング: ウィジェットが正しく表示される
- ユーザー操作: タップ、スクロール、入力などの動作
- 状態変化: 状態が変わった時の表示更新
- バリデーション: 入力検証の動作

**命名規則**:
```dart
testWidgets('ウィジェット名_動作_期待される結果', (tester) async {
  // 例: 'LoginButton_whenTapped_showsLoadingIndicator'
});
```

### Integration Test（統合テスト）
**対象**: エンドツーエンドのユーザーフロー

**必須テストケース**:
- 主要なユーザーフロー
- 認証フロー
- データの永続化と復元

## コーディング規則

### テストファイル構成
```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';

// テスト対象のインポート
import 'package:your_app/...';

// Mockの生成（必要な場合）
@GenerateMocks([ClassName])
void main() {
  group('クラス名/機能名のグループ', () {
    // 共通の変数
    late TargetClass target;
    late MockDependency mockDependency;

    // 各テストの前に実行
    setUp(() {
      mockDependency = MockDependency();
      target = TargetClass(dependency: mockDependency);
    });

    // 各テストの後に実行（必要な場合）
    tearDown(() {
      // クリーンアップ処理
    });

    group('メソッド名/機能名のサブグループ', () {
      test('具体的なテストケース1', () {
        // Arrange: テスト準備
        final input = 'test input';
        final expected = 'expected output';

        // Act: テスト実行
        final result = target.method(input);

        // Assert: 検証
        expect(result, expected);
      });

      test('具体的なテストケース2', () {
        // ...
      });
    });
  });
}
```

### Mockの使用規則
```dart
// 1. 依存関係は抽象クラス/インターフェースにする
abstract class ApiClient {
  Future get(String url);
}

// 2. Mockアノテーションで生成
@GenerateMocks([ApiClient])

// 3. テスト内でモックの振る舞いを定義
test('example test', () {
  // 戻り値を設定
  when(mockClient.get(any))
      .thenAnswer((_) async => Response('data', 200));

  // テスト実行
  final result = await service.fetchData();

  // 呼び出しを検証
  verify(mockClient.get('https://api.example.com/data')).called(1);
  
  // 結果を検証
  expect(result, 'data');
});
```

### Widget Testのベストプラクティス
```dart
testWidgets('example widget test', (tester) async {
  // 1. Widget Keyを使用して要素を特定
  const emailFieldKey = Key('email_field');
  const submitButtonKey = Key('submit_button');

  // 2. MaterialAppでラップ
  await tester.pumpWidget(
    MaterialApp(
      home: Scaffold(
        body: YourWidget(),
      ),
    ),
  );

  // 3. 要素の存在確認
  expect(find.byKey(emailFieldKey), findsOneWidget);

  // 4. ユーザー操作をシミュレート
  await tester.enterText(find.byKey(emailFieldKey), 'test@example.com');
  await tester.tap(find.byKey(submitButtonKey));

  // 5. アニメーションやステート更新を待つ
  await tester.pump(); // 1フレーム進める
  await tester.pumpAndSettle(); // すべてのアニメーション完了まで待つ

  // 6. 結果を検証
  expect(find.text('Success'), findsOneWidget);
});
```

## エラーハンドリングのテスト
```dart
group('Error Handling', () {
  test('throws specific exception on error', () {
    // expect with throwsA
    expect(
      () => target.methodThatThrows(),
      throwsA(isA()),
    );
  });

  test('handles async errors correctly', () async {
    // expect with throwsA for async
    expect(
      target.asyncMethodThatThrows(),
      throwsA(isA()),
    );
  });

  test('error message is correct', () {
    try {
      target.methodThatThrows();
      fail('Exception should be thrown');
    } catch (e) {
      expect(e.toString(), contains('expected error message'));
    }
  });
});
```

## テストデータの管理
```dart
// test/fixtures/test_data.dart
class TestData {
  static User validUser() => User(
    id: 1,
    name: 'Test User',
    email: 'test@example.com',
    age: 25,
  );

  static User invalidUser() => User(
    id: -1,
    name: '',
    email: 'invalid-email',
    age: -5,
  );

  static List userList() => [
    validUser(),
    User(id: 2, name: 'User 2', email: 'user2@test.com', age: 30),
    User(id: 3, name: 'User 3', email: 'user3@test.com', age: 15),
  ];
}
```

## 避けるべきアンチパターン

❌ **やってはいけないこと**:
```dart
// テスト間で状態を共有
var sharedState = SomeObject(); // NG

// 複数の検証を1つのテストに詰め込む
test('does everything', () {
  // 複数の無関係な検証 - NG
});

// 具体的でない説明
test('test1', () {}); // NG

// setUp内で複雑なロジック
setUp(() {
  // 複雑な初期化ロジック - NG
});

// テスト内でsleep/delayを使う
await Future.delayed(Duration(seconds: 1)); // NG
```

✅ **推奨されること**:
```dart
// 各テストで新しいインスタンスを作成
setUp(() {
  target = TargetClass();
});

// 1つのテストで1つの検証
test('validates email format correctly', () {
  expect(validator.isValidEmail('test@test.com'), true);
});

// 説明的なテスト名
test('getUserById_whenUserExists_returnsUser', () {});

// pumpを使ってアニメーションを制御
await tester.pumpAndSettle();
```

## 出力フォーマット

テストコードを作成する際は、以下の形式で出力してください:

1. **ファイルパス**: `test/path/to/file_test.dart`
2. **完全なテストコード**: 実行可能な完全なコード
3. **テストケースの説明**: 何をテストしているか
4. **カバレッジ情報**: このテストでカバーされる範囲

## 実装例

実装コードを提示された場合:
1. ファイルパスを確認
2. 必要なテストケースをリストアップ
3. 上記の規則に従ってテストコードを作成
4. エッジケースも含める
5. Mockが必要な依存関係を特定

質問がある場合は明確にし、テストコードは実行可能な状態で提供してください。
```

---

## Cursor で使う際の具体的なプロンプト例

### プロンプト1: 新規テスト作成
```
以下のFlutterクラスに対して、上記の「Flutter Test Code Development Standards」に従って
完全なテストコードを作成してください。

[実装コードを貼り付け]

以下を含めてください:
- 正常系のテスト
- 異常系のテスト
- 境界値のテスト
- 必要に応じてMockの使用
```

### プロンプト2: 既存テストの改善
```
以下のテストコードを「Flutter Test Code Development Standards」に基づいてレビューし、
改善案を提示してください。

[既存のテストコードを貼り付け]

特に以下の点を確認してください:
- テストカバレッジの不足
- アンチパターンの使用
- 命名規則の遵守
```

### プロンプト3: Widget テスト作成
```
以下のFlutterウィジェットに対して、「Flutter Test Code Development Standards」の
Widget Test規則に従ってテストコードを作成してください。

[Widgetコードを貼り付け]

以下のテストケースを含めてください:
- レンダリングテスト
- ユーザーインタラクションテスト
- 状態変化のテスト
```

---

# CI/CD 設定ガイド

このプロジェクトは **GitHub Actions** を使用してCI（継続的インテグレーション）を実装しています。

## 📋 CI の概要

### 目的
- コードの品質を保証する
- プルリクエストやプッシュ時に自動的にテストを実行する
- テストが失敗した場合に早期に問題を検出する

### 実行タイミング
- **プルリクエスト**: PR作成時、更新時
- **プッシュ**: mainブランチへのプッシュ時
- **手動実行**: GitHub ActionsのUIから手動で実行可能

## 🔧 CI ワークフローの構成

### 実行内容
1. **Flutter環境のセットアップ**
   - 最新の安定版Flutter SDKをインストール
   - キャッシュを活用して高速化

2. **依存関係のインストール**
   ```bash
   flutter pub get
   ```

3. **Mockファイルの生成**
   ```bash
   flutter pub run build_runner build --delete-conflicting-outputs
   ```

4. **コード解析**
   ```bash
   flutter analyze
   ```

5. **テストの実行**
   ```bash
   flutter test --coverage
   ```

6. **カバレッジレポートの生成**
   - テストカバレッジを計算
   - カバレッジレポートをアーティファクトとして保存

## 📁 ワークフローファイルの場所

```
.github/
└── workflows/
    └── test.yml          # テスト実行ワークフロー
```

## 🎯 CI の目標

- **テストカバレッジ**: 80%以上を維持
- **コード解析**: 警告やエラーがない状態を維持
- **テスト実行時間**: 5分以内で完了

## ✅ CI が成功する条件

1. ✅ すべてのテストが成功する
2. ✅ `flutter analyze` でエラーや警告がない
3. ✅ テストカバレッジが目標値を満たしている

## 🚫 CI が失敗する場合

CIが失敗した場合、以下の点を確認してください：

1. **テストの失敗**
   - 失敗したテストのログを確認
   - ローカルで `flutter test` を実行して再現する

2. **コード解析エラー**
   - `flutter analyze` をローカルで実行
   - 指摘された問題を修正

3. **依存関係の問題**
   - `flutter pub get` が正常に完了するか確認
   - `pubspec.yaml` の依存関係を確認

## 🔄 ローカルでのCI再現

CIと同じ環境でテストを実行する場合：

```bash
# 依存関係のインストール
flutter pub get

# Mockファイルの生成
flutter pub run build_runner build --delete-conflicting-outputs

# コード解析
flutter analyze

# テスト実行
flutter test --coverage
```

## 📊 カバレッジレポートの確認

CI実行後、GitHub Actionsのアーティファクトからカバレッジレポートをダウンロードできます。

ローカルで確認する場合：

```bash
flutter test --coverage
genhtml coverage/lcov.info -o coverage/html
open coverage/html/index.html
```

## 🔐 シークレットと環境変数

現在、CIではシークレットや環境変数は使用していません。
将来的にAPIキーなどが必要になった場合は、GitHubのリポジトリ設定から追加できます。

## 📝 注意事項

- CIは現在**テスト実行のみ**を対象としています
- CD（継続的デプロイ）は後ほど実装予定です
- MockファイルはCI実行時に自動生成されます
- キャッシュを活用して実行時間を短縮しています

---

**重要**: プルリクエストを作成する前に、ローカルで `flutter test` と `flutter analyze` が成功することを確認してください。